#!/usr/bin/env python
# encoding: utf-8
"""

@author:nikan

@file: {{spider_name}}.py

@time: {{datetime}}
"""
from typing import List

from scrapy import Request
from scrapy.crawler import CrawlerProcess
from scrapy.http import TextResponse
from scrapy.link import Link
from scrapy.mail import MailSender
from scrapy.spidermiddlewares.httperror import HttpError
from scrapy.spiders import Spider

from PyScraper.extractor.blank_html import BlankHtmlExtractor
from PyScraper.extractor.error_correction import ErrorCorrectionExtractor
from PyScraper.extractor.html_link import HtmlLinkExtractor
from PyScraper.extractor.xml_link import DataProxyXmlLinkExtractor
from PyScraper.utils.mail import render_error_correction_result_mail


class {{spider_name}}Spider(Spider):
    name = '{{spider_name}}'
    allowed_domains = ['{{allowed_domain}}']
    start_urls = ['{{start_url}}']
    rules = [
    {% for rule in rules -%}
    {{rule}},
    {% endfor -%}

    ]
    htmk_link_extractor = HtmlLinkExtractor()
    error_correction_extractor = ErrorCorrectionExtractor(rules, domain='{{allowed_domain}}')
    blank_html_extractor = BlankHtmlExtractor()
    custom_settings = {
    # 'CONCURRENT_REQUESTS_PER_DOMAIN' : 4,
    'LOG_LEVEL': 'INFO'
    # 'DOWNLOAD_DELAY': 0.3,
    }

    def parse(self, response: TextResponse):
        request_url = response.meta.get("url")
        previous_url = response.meta.get("previous_url")
        response_is_blank = self.blank_html_extractor.is_blank(response)
        if response_is_blank:
            blank_result = {'type': 'error_link', 'reason': '网页内容为空', 'url': request_url or response.url, 'content': response.text,  "previous_url": previous_url, , 'status': 200}
            yield blank_result


        error_correction_result = self.error_correction_extractor.find_error(response)
        if error_correction_result:
            print("error_correction_result", error_correction_result)

            message = "\n".join(["正确词：{} 错误词： {}".format(error['correct'], error['error']) for error in error_correction_result])
            yield {'type': 'error_word', 'reason': '网页中有错误词:\n' + message, 'url': request_url or response.url, 'content': response.text, 'error': error_correction_result}


        links: List[Link] = [lnk for lnk in self.htmk_link_extractor.extract_links(response)]
        for link in links:
            yield Request(link.url, callback=self.parse, errback=self.errorback,
                            meta={"url": link.url, "previous_url": previous_url})
        """
        获取dataproxy接口的链接
        """
        data_proxy_extractor = DataProxyXmlLinkExtractor()
        if data_proxy_extractor.has_dataproxy_link(response):
            yield data_proxy_extractor.gen_dataproxy_links()

    def errorback(self, failure):
        if isinstance(failure.value, HttpError):
            response = failure.value.response
            request_url = response.meta.get("url")
            previous_url = response.meta.get("previous_url")
            result = {'type': 'error_link', 'reason': '错误链接{}'.format(response.status), 'status': response.status, 'url': request_url or response.url, 'content': None,  "previous_url": previous_url}
            yield result


        print('response is error in response.url:', failure)


if __name__ == '__main__':
    settings = {
        "TELNETCONSOLE_ENABLED": False,
        # "LOG_FILE": "./wzkjj.log"
    }
    process = CrawlerProcess(settings=settings)
    process.crawl({{spider_name}}Spider)
    process.start()
